<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            가장 짧은 문자거리
            1. 한 개의 문자열과 문자 1개를 입력받는다
            2. 각 문자가 입력 받은 문자 1개와의 최소 거리를 계산한다. 
            3. 각 문자마다 최소 거리 정보를 담아 출력한다. 

            해결
            1. split() 함수를 이용해 특정 문자를 기준으로 나누고 배열을 만든다. 
            2. 그러면 각 문자열의 길이을 알 수 있다.
            이 문자열은 양 옆에서 1,2,3,...순차적으로 커지고 문자열의 절반 길이 만큼 커진다.
            이때 짝수의 경우엔 1,2,2,1 이렇게 되고
            홀수의 경우엔 1,2,1 이렇게 나뉜다. 
            3. 따라서 각 문자열의 길이를 홀짝에 따라 경우를 나누어 문자열의 길이 절반 값을 정점으로해
            거리 정보를 출력한다. 
            4. 그리고 각 출력이 끝난 후 특정문자의 거리값인 0을 입력한다.  
        */
        function solution (word, key) {
            let answer = "";
            let value = 0;
            let test = word.split(key);
            for(let i=0; i<test.length-1; i++) {
                if((test[i].length)%2 === 0) {
                    value = parseInt(test[i].length/2);
                    console.log(value);
                    for(let j=1; j<=value; j++) {
                        answer += j + " ";
                    }
                    for(let j=value; j>0; j--) {
                        answer += j + " ";
                    }
                } else {
                    value = parseInt((test[i].length/2))+1;
                    console.log(value);
                    for(let j=1; j<=value; j++) {
                        answer += j + " ";
                    }
                    for(let j=value-1; j>0; j--) {
                        answer += j + " ";
                    }
                }
                answer += "0" + " ";
            }
            return answer;
            /*
                다른 해결 방법
                1. 입력받은 문자열을 왼쪽에서 오른쪽, 오른쪽에서 왼쪽으로 탐색을 실행한다. 
                2. 왼쪽에서 오른쪽으로 탐색할때 왼쪽에 있는 key 단어와의 거리를 계산해 배열에 저장한다. 
                만약 왼쪽에 key 단어가 없는 경우 임의의 큰 숫자(문자열보다 큰 값)로 설정한다.
                3. 오른쪽에서 왼쪽으로 탐색할 때 다시 거리를 계산하되 배열에 저장할 때는 2번과정에서 얻은 거리 값과
                비교해 보다 작은 값을 배열에 저장한다. 
                4. 그리고 출력한다.  
            */
        //    let answer2 =[];
        //    let p = 1000;
        //    // 왼쪽에서 오른쪽 탐색
        //    for(let x of word) {
        //        if(word === key) {
        //            p = 0;
        //            answer.push(p);
        //        } else {
        //            p++;
        //            answer.push(p);
        //        }
        //    }

        //    // 오른쪽에서 왼쪽으로 탐색
        //    p=1000; 
        //    for(let i=word.length-1; i>=0; i--) {
        //        if(word[i]===key) {
        //            p=0;
        //        } else {
        //            p++;
        //            answer[i]=Math.min(answer[i], p);
        //        }
        //    }
        //    return answer2;
        }
        let str = "teaasdfaqcherwewmode";
        console.log(solution(str, 'e'));
    </script>
</body>
</html>